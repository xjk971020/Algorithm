# leetcode刷题日志 -- 贪心

---

begin: 2019-8-28

## 贪心算法

### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
- **题目描述**

- 给定一个非负整数数组，你最初位于数组的第一个位置。

  数组中的每个元素代表你在该位置可以跳跃的最大长度。

  判断你是否能够到达最后一个位置。

  示例 1:

  输入: [2,3,1,1,4]
  输出: true
  解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
  示例 2:

  输入: [3,2,1,0,4]
  输出: false
  解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

- **题目答案**
- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/CanJump.java

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

- **题目描述**

- 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

  示例 1:

  输入: [7,1,5,3,6,4]
  输出: 7
  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
       随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
  示例 2:

  输入: [1,2,3,4,5]
  输出: 4
  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
       注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
       因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
  示例 3:

  输入: [7,6,4,3,1]
  输出: 0
  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/BestTimeToBuyAndSellStockII.java

### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

- **题目描述**

- 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

  你需要按照以下要求，帮助老师给这些孩子分发糖果：

  每个孩子至少分配到 1 个糖果。
  相邻的孩子中，评分高的孩子必须获得更多的糖果。
  那么这样下来，老师至少需要准备多少颗糖果呢？

  示例 1:

  输入: [1,0,2]
  输出: 5
  解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
  示例 2:

  输入: [1,2,2]
  输出: 4
  解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
       第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/Candy.java

### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

- **题目描述**

- 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

  你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

  字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

  示例 1:
  s = "abc", t = "ahbgdc"

  返回 true.

  示例 2:
  s = "axc", t = "ahbgdc"

  返回 false.

  后续挑战 :

  如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码?

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/IsSubsequence.java

### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

- **题目描述**

- 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

  注意：

  你可以假设胃口值为正。
  一个小朋友最多只能拥有一块饼干。

  示例 1:

  输入: [1,2,3], [1,1]

  输出: 1

  解释: 
  你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
  虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
  所以你应该输出1。
  示例 2:

  输入: [1,2], [1,2,3]

  输出: 2

  解释: 
  你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
  你拥有的饼干数量和尺寸都足以让所有孩子满足。
  所以你应该输出2.

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/FindContentChildren.java

### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

- **题目描述**

- 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

  顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

  每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

  注意，一开始你手头没有任何零钱。

  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

  示例 1：

  输入：[5,5,5,10,20]
  输出：true
  解释：
  前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
  第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
  第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
  由于所有客户都得到了正确的找零，所以我们输出 true。
  示例 2：

  输入：[5,5,10]
  输出：true
  示例 3：

  输入：[10,10]
  输出：false
  示例 4：

  输入：[5,5,10,10,20]
  输出：false
  解释：
  前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
  对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
  对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
  由于不是每位顾客都得到了正确的找零，所以答案是 false。

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/LemonadeChange.java

### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

- **题目描述**

- 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

  （当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

  示例 1:

  输入: N = 10
  输出: 9
  示例 2:

  输入: N = 1234
  输出: 1234
  示例 3:

  输入: N = 332
  输出: 299
  说明: N 是在 [0, 10^9] 范围内的一个整数。

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/MonotoneIncreasingDigits.java

### [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

- **题目描述**

- 有一堆石头，每块石头的重量都是正整数。

  每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

  如果 x == y，那么两块石头都会被完全粉碎；
  如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
  最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

   

  提示：

  1 <= stones.length <= 30
  1 <= stones[i] <= 1000

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/LastStoneWeight.java

### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

- **题目描述**

- 给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

  示例 1:

  输入: "bcabc"
  输出: "abc"
  示例 2:

  输入: "cbacdcbc"
  输出: "acdb"

- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/RemoveDuplicateLetters.java

### [1029. 两地调度](https://leetcode-cn.com/problems/two-city-scheduling/)

- **题目描述**

- 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。
  
  返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。
  
  示例：
  
  输入：[[10,20],[30,200],[400,50],[30,20]]
  输出：110
  解释：
  第一个人去 A 市，费用为 10。
  第二个人去 A 市，费用为 30。
  第三个人去 B 市，费用为 50。
  第四个人去 B 市，费用为 20。
  
  最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
   
  
  提示：
  
  1 <= costs.length <= 100
  costs.length 为偶数
  1 <= costs[i][0], costs[i][1] <= 1000
 
- **题目答案**

- https://github.com/xjk971020/Algorithm/blob/master/src/leetcode/TwoCitySchedCost.java



